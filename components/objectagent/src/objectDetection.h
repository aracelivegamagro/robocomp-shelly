// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `objectDetection.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ____objectDetection_h__
#define ____objectDetection_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace RoboCompobjectDetection
{

class objectDetection;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompobjectDetection::objectDetection>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompobjectDetection::objectDetection*);

}

}

namespace RoboCompobjectDetection
{

class objectDetection;
bool operator==(const objectDetection&, const objectDetection&);
bool operator<(const objectDetection&, const objectDetection&);
::Ice::Object* upCast(::RoboCompobjectDetection::objectDetection*);
typedef ::IceInternal::Handle< ::RoboCompobjectDetection::objectDetection> objectDetectionPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompobjectDetection::objectDetection> objectDetectionPrx;
void __patch(objectDetectionPtr&, const ::Ice::ObjectPtr&);

}

namespace RoboCompobjectDetection
{

typedef ::std::vector< ::std::string> listType;

}

namespace RoboCompobjectDetection
{

class Callback_objectDetection_statisticalOutliersRemoval_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_statisticalOutliersRemoval_Base> Callback_objectDetection_statisticalOutliersRemovalPtr;

class Callback_objectDetection_passThrough_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_passThrough_Base> Callback_objectDetection_passThroughPtr;

class Callback_objectDetection_grabThePointCloud_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_grabThePointCloud_Base> Callback_objectDetection_grabThePointCloudPtr;

class Callback_objectDetection_aprilFitModel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_aprilFitModel_Base> Callback_objectDetection_aprilFitModelPtr;

class Callback_objectDetection_fitModel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_fitModel_Base> Callback_objectDetection_fitModelPtr;

class Callback_objectDetection_getInliers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_getInliers_Base> Callback_objectDetection_getInliersPtr;

class Callback_objectDetection_projectInliers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_projectInliers_Base> Callback_objectDetection_projectInliersPtr;

class Callback_objectDetection_convexHull_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_convexHull_Base> Callback_objectDetection_convexHullPtr;

class Callback_objectDetection_extractPolygon_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_extractPolygon_Base> Callback_objectDetection_extractPolygonPtr;

class Callback_objectDetection_ransac_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_ransac_Base> Callback_objectDetection_ransacPtr;

class Callback_objectDetection_normalSegmentation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_normalSegmentation_Base> Callback_objectDetection_normalSegmentationPtr;

class Callback_objectDetection_euclideanClustering_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_euclideanClustering_Base> Callback_objectDetection_euclideanClusteringPtr;

class Callback_objectDetection_showObject_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_showObject_Base> Callback_objectDetection_showObjectPtr;

class Callback_objectDetection_reset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_reset_Base> Callback_objectDetection_resetPtr;

class Callback_objectDetection_mirrorPC_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_mirrorPC_Base> Callback_objectDetection_mirrorPCPtr;

class Callback_objectDetection_mindTheGapPC_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_mindTheGapPC_Base> Callback_objectDetection_mindTheGapPCPtr;

class Callback_objectDetection_reloadVFH_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_reloadVFH_Base> Callback_objectDetection_reloadVFHPtr;

class Callback_objectDetection_loadTrainedVFH_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_loadTrainedVFH_Base> Callback_objectDetection_loadTrainedVFHPtr;

class Callback_objectDetection_fitTheViewVFH_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_fitTheViewVFH_Base> Callback_objectDetection_fitTheViewVFHPtr;

class Callback_objectDetection_vfh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_vfh_Base> Callback_objectDetection_vfhPtr;

class Callback_objectDetection_surfHomography_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_surfHomography_Base> Callback_objectDetection_surfHomographyPtr;

class Callback_objectDetection_centroidBasedPose_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_centroidBasedPose_Base> Callback_objectDetection_centroidBasedPosePtr;

class Callback_objectDetection_segmentImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_segmentImage_Base> Callback_objectDetection_segmentImagePtr;

class Callback_objectDetection_grabTheAR_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_grabTheAR_Base> Callback_objectDetection_grabTheARPtr;

class Callback_objectDetection_getPose_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_objectDetection_getPose_Base> Callback_objectDetection_getPosePtr;

}

namespace IceProxy
{

namespace RoboCompobjectDetection
{

class objectDetection : virtual public ::IceProxy::Ice::Object
{
public:

    void statisticalOutliersRemoval()
    {
        statisticalOutliersRemoval(0);
    }
    void statisticalOutliersRemoval(const ::Ice::Context& __ctx)
    {
        statisticalOutliersRemoval(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_statisticalOutliersRemoval(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_statisticalOutliersRemoval(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_statisticalOutliersRemoval(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_statisticalOutliersRemoval(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_statisticalOutliersRemoval(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_statisticalOutliersRemoval(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_statisticalOutliersRemoval(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_statisticalOutliersRemoval(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval()
    {
        return begin_statisticalOutliersRemoval(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::Ice::Context& __ctx)
    {
        return begin_statisticalOutliersRemoval(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_statisticalOutliersRemoval(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_statisticalOutliersRemoval(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::RoboCompobjectDetection::Callback_objectDetection_statisticalOutliersRemovalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_statisticalOutliersRemoval(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_statisticalOutliersRemovalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_statisticalOutliersRemoval(&__ctx, __del, __cookie);
    }

    void end_statisticalOutliersRemoval(const ::Ice::AsyncResultPtr&);
    
private:

    void statisticalOutliersRemoval(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_statisticalOutliersRemoval(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void passThrough()
    {
        passThrough(0);
    }
    void passThrough(const ::Ice::Context& __ctx)
    {
        passThrough(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_passThrough(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_passThrough(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_passThrough(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_passThrough(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_passThrough(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_passThrough(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_passThrough(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_passThrough(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_passThrough()
    {
        return begin_passThrough(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_passThrough(const ::Ice::Context& __ctx)
    {
        return begin_passThrough(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_passThrough(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_passThrough(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_passThrough(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_passThrough(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_passThrough(const ::RoboCompobjectDetection::Callback_objectDetection_passThroughPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_passThrough(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_passThrough(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_passThroughPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_passThrough(&__ctx, __del, __cookie);
    }

    void end_passThrough(const ::Ice::AsyncResultPtr&);
    
private:

    void passThrough(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_passThrough(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void grabThePointCloud(const ::std::string& image, const ::std::string& pcd)
    {
        grabThePointCloud(image, pcd, 0);
    }
    void grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx)
    {
        grabThePointCloud(image, pcd, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_grabThePointCloud(image, pcd, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_grabThePointCloud(image, pcd, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_grabThePointCloud(image, pcd, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_grabThePointCloud(image, pcd, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd)
    {
        return begin_grabThePointCloud(image, pcd, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx)
    {
        return begin_grabThePointCloud(image, pcd, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabThePointCloud(image, pcd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabThePointCloud(image, pcd, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::RoboCompobjectDetection::Callback_objectDetection_grabThePointCloudPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabThePointCloud(image, pcd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_grabThePointCloudPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabThePointCloud(image, pcd, &__ctx, __del, __cookie);
    }

    void end_grabThePointCloud(const ::Ice::AsyncResultPtr&);
    
private:

    void grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void aprilFitModel(const ::std::string& model)
    {
        aprilFitModel(model, 0);
    }
    void aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        aprilFitModel(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_aprilFitModel(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_aprilFitModel(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_aprilFitModel(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_aprilFitModel(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_aprilFitModel(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_aprilFitModel(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model)
    {
        return begin_aprilFitModel(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_aprilFitModel(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_aprilFitModel(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_aprilFitModel(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_aprilFitModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_aprilFitModel(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_aprilFitModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_aprilFitModel(model, &__ctx, __del, __cookie);
    }

    void end_aprilFitModel(const ::Ice::AsyncResultPtr&);
    
private:

    void aprilFitModel(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_aprilFitModel(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void fitModel(const ::std::string& model, const ::std::string& method)
    {
        fitModel(model, method, 0);
    }
    void fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx)
    {
        fitModel(model, method, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fitModel(const ::std::string& model, const ::std::string& method, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_fitModel(model, method, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_fitModel(const ::std::string& model, const ::std::string& method, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fitModel(model, method, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_fitModel(model, method, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fitModel(model, method, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method)
    {
        return begin_fitModel(model, method, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx)
    {
        return begin_fitModel(model, method, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitModel(model, method, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitModel(model, method, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method, const ::RoboCompobjectDetection::Callback_objectDetection_fitModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitModel(model, method, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_fitModelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitModel(model, method, &__ctx, __del, __cookie);
    }

    void end_fitModel(const ::Ice::AsyncResultPtr&);
    
private:

    void fitModel(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fitModel(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getInliers(const ::std::string& model)
    {
        getInliers(model, 0);
    }
    void getInliers(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        getInliers(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getInliers(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_getInliers(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_getInliers(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInliers(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_getInliers(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getInliers(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model)
    {
        return begin_getInliers(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_getInliers(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInliers(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInliers(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_getInliersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInliers(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_getInliersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInliers(model, &__ctx, __del, __cookie);
    }

    void end_getInliers(const ::Ice::AsyncResultPtr&);
    
private:

    void getInliers(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInliers(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void projectInliers(const ::std::string& model)
    {
        projectInliers(model, 0);
    }
    void projectInliers(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        projectInliers(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_projectInliers(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_projectInliers(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_projectInliers(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_projectInliers(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_projectInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_projectInliers(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_projectInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_projectInliers(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model)
    {
        return begin_projectInliers(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_projectInliers(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_projectInliers(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_projectInliers(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_projectInliersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_projectInliers(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_projectInliersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_projectInliers(model, &__ctx, __del, __cookie);
    }

    void end_projectInliers(const ::Ice::AsyncResultPtr&);
    
private:

    void projectInliers(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_projectInliers(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void convexHull(const ::std::string& model)
    {
        convexHull(model, 0);
    }
    void convexHull(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        convexHull(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_convexHull(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_convexHull(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_convexHull(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_convexHull(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_convexHull(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_convexHull(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_convexHull(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_convexHull(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model)
    {
        return begin_convexHull(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_convexHull(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_convexHull(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_convexHull(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_convexHullPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_convexHull(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_convexHullPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_convexHull(model, &__ctx, __del, __cookie);
    }

    void end_convexHull(const ::Ice::AsyncResultPtr&);
    
private:

    void convexHull(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_convexHull(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void extractPolygon(const ::std::string& model)
    {
        extractPolygon(model, 0);
    }
    void extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        extractPolygon(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_extractPolygon(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_extractPolygon(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_extractPolygon(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_extractPolygon(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_extractPolygon(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_extractPolygon(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model)
    {
        return begin_extractPolygon(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_extractPolygon(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_extractPolygon(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_extractPolygon(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_extractPolygonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_extractPolygon(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_extractPolygonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_extractPolygon(model, &__ctx, __del, __cookie);
    }

    void end_extractPolygon(const ::Ice::AsyncResultPtr&);
    
private:

    void extractPolygon(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_extractPolygon(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void ransac(const ::std::string& model)
    {
        ransac(model, 0);
    }
    void ransac(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        ransac(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ransac(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ransac(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_ransac(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ransac(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ransac(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ransac(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ransac(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ransac(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model)
    {
        return begin_ransac(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_ransac(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ransac(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ransac(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_ransacPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ransac(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ransac(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_ransacPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ransac(model, &__ctx, __del, __cookie);
    }

    void end_ransac(const ::Ice::AsyncResultPtr&);
    
private:

    void ransac(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ransac(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void normalSegmentation(const ::std::string& model)
    {
        normalSegmentation(model, 0);
    }
    void normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        normalSegmentation(model, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_normalSegmentation(const ::std::string& model, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_normalSegmentation(model, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_normalSegmentation(const ::std::string& model, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_normalSegmentation(model, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_normalSegmentation(model, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_normalSegmentation(model, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model)
    {
        return begin_normalSegmentation(model, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx)
    {
        return begin_normalSegmentation(model, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_normalSegmentation(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_normalSegmentation(model, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model, const ::RoboCompobjectDetection::Callback_objectDetection_normalSegmentationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_normalSegmentation(model, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string& model, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_normalSegmentationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_normalSegmentation(model, &__ctx, __del, __cookie);
    }

    void end_normalSegmentation(const ::Ice::AsyncResultPtr&);
    
private:

    void normalSegmentation(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_normalSegmentation(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void euclideanClustering(::Ice::Int& numCluseters)
    {
        euclideanClustering(numCluseters, 0);
    }
    void euclideanClustering(::Ice::Int& numCluseters, const ::Ice::Context& __ctx)
    {
        euclideanClustering(numCluseters, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_euclideanClustering(const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_euclideanClustering(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_euclideanClustering(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_euclideanClustering(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_euclideanClustering(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_euclideanClustering(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_euclideanClustering(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_euclideanClustering(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_euclideanClustering(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
                ::Ice::Int numCluseters;
                try
                {
                    __proxy->end_euclideanClustering(numCluseters, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(numCluseters);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Int)> _response;
        };
        return begin_euclideanClustering(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_euclideanClustering()
    {
        return begin_euclideanClustering(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::Ice::Context& __ctx)
    {
        return begin_euclideanClustering(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_euclideanClustering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_euclideanClustering(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::RoboCompobjectDetection::Callback_objectDetection_euclideanClusteringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_euclideanClustering(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_euclideanClusteringPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_euclideanClustering(&__ctx, __del, __cookie);
    }

    void end_euclideanClustering(::Ice::Int& numCluseters, const ::Ice::AsyncResultPtr&);
    
private:

    void euclideanClustering(::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_euclideanClustering(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void showObject(::Ice::Int numObject)
    {
        showObject(numObject, 0);
    }
    void showObject(::Ice::Int numObject, const ::Ice::Context& __ctx)
    {
        showObject(numObject, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_showObject(::Ice::Int numObject, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_showObject(numObject, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_showObject(::Ice::Int numObject, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_showObject(numObject, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_showObject(::Ice::Int numObject, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_showObject(numObject, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_showObject(::Ice::Int numObject, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_showObject(numObject, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject)
    {
        return begin_showObject(numObject, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject, const ::Ice::Context& __ctx)
    {
        return begin_showObject(numObject, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_showObject(numObject, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_showObject(numObject, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject, const ::RoboCompobjectDetection::Callback_objectDetection_showObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_showObject(numObject, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int numObject, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_showObjectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_showObject(numObject, &__ctx, __del, __cookie);
    }

    void end_showObject(const ::Ice::AsyncResultPtr&);
    
private:

    void showObject(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_showObject(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reset()
    {
        reset(0);
    }
    void reset(const ::Ice::Context& __ctx)
    {
        reset(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reset(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reset(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_reset(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reset(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reset(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reset(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reset(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reset(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_reset()
    {
        return begin_reset(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Ice::Context& __ctx)
    {
        return begin_reset(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reset(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::RoboCompobjectDetection::Callback_objectDetection_resetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_resetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reset(&__ctx, __del, __cookie);
    }

    void end_reset(const ::Ice::AsyncResultPtr&);
    
private:

    void reset(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reset(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mirrorPC()
    {
        mirrorPC(0);
    }
    void mirrorPC(const ::Ice::Context& __ctx)
    {
        mirrorPC(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mirrorPC(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_mirrorPC(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_mirrorPC(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mirrorPC(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mirrorPC(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_mirrorPC(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mirrorPC(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mirrorPC(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_mirrorPC()
    {
        return begin_mirrorPC(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mirrorPC(const ::Ice::Context& __ctx)
    {
        return begin_mirrorPC(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mirrorPC(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mirrorPC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mirrorPC(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mirrorPC(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mirrorPC(const ::RoboCompobjectDetection::Callback_objectDetection_mirrorPCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mirrorPC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mirrorPC(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_mirrorPCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mirrorPC(&__ctx, __del, __cookie);
    }

    void end_mirrorPC(const ::Ice::AsyncResultPtr&);
    
private:

    void mirrorPC(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mirrorPC(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mindTheGapPC()
    {
        mindTheGapPC(0);
    }
    void mindTheGapPC(const ::Ice::Context& __ctx)
    {
        mindTheGapPC(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mindTheGapPC(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_mindTheGapPC(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_mindTheGapPC(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mindTheGapPC(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mindTheGapPC(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_mindTheGapPC(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mindTheGapPC(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mindTheGapPC(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_mindTheGapPC()
    {
        return begin_mindTheGapPC(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::Ice::Context& __ctx)
    {
        return begin_mindTheGapPC(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mindTheGapPC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mindTheGapPC(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::RoboCompobjectDetection::Callback_objectDetection_mindTheGapPCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mindTheGapPC(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_mindTheGapPCPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mindTheGapPC(&__ctx, __del, __cookie);
    }

    void end_mindTheGapPC(const ::Ice::AsyncResultPtr&);
    
private:

    void mindTheGapPC(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mindTheGapPC(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reloadVFH(const ::std::string& pathToSet)
    {
        reloadVFH(pathToSet, 0);
    }
    void reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx)
    {
        reloadVFH(pathToSet, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reloadVFH(const ::std::string& pathToSet, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reloadVFH(pathToSet, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_reloadVFH(const ::std::string& pathToSet, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reloadVFH(pathToSet, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reloadVFH(pathToSet, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reloadVFH(pathToSet, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet)
    {
        return begin_reloadVFH(pathToSet, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx)
    {
        return begin_reloadVFH(pathToSet, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadVFH(pathToSet, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadVFH(pathToSet, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet, const ::RoboCompobjectDetection::Callback_objectDetection_reloadVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadVFH(pathToSet, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_reloadVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reloadVFH(pathToSet, &__ctx, __del, __cookie);
    }

    void end_reloadVFH(const ::Ice::AsyncResultPtr&);
    
private:

    void reloadVFH(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reloadVFH(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void loadTrainedVFH()
    {
        loadTrainedVFH(0);
    }
    void loadTrainedVFH(const ::Ice::Context& __ctx)
    {
        loadTrainedVFH(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_loadTrainedVFH(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_loadTrainedVFH(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_loadTrainedVFH(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_loadTrainedVFH(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_loadTrainedVFH(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_loadTrainedVFH(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_loadTrainedVFH(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_loadTrainedVFH(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_loadTrainedVFH()
    {
        return begin_loadTrainedVFH(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::Ice::Context& __ctx)
    {
        return begin_loadTrainedVFH(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loadTrainedVFH(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loadTrainedVFH(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::RoboCompobjectDetection::Callback_objectDetection_loadTrainedVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loadTrainedVFH(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_loadTrainedVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loadTrainedVFH(&__ctx, __del, __cookie);
    }

    void end_loadTrainedVFH(const ::Ice::AsyncResultPtr&);
    
private:

    void loadTrainedVFH(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_loadTrainedVFH(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void fitTheViewVFH()
    {
        fitTheViewVFH(0);
    }
    void fitTheViewVFH(const ::Ice::Context& __ctx)
    {
        fitTheViewVFH(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fitTheViewVFH(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_fitTheViewVFH(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_fitTheViewVFH(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fitTheViewVFH(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fitTheViewVFH(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_fitTheViewVFH(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fitTheViewVFH(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fitTheViewVFH(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_fitTheViewVFH()
    {
        return begin_fitTheViewVFH(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::Ice::Context& __ctx)
    {
        return begin_fitTheViewVFH(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitTheViewVFH(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitTheViewVFH(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::RoboCompobjectDetection::Callback_objectDetection_fitTheViewVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitTheViewVFH(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_fitTheViewVFHPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fitTheViewVFH(&__ctx, __del, __cookie);
    }

    void end_fitTheViewVFH(const ::Ice::AsyncResultPtr&);
    
private:

    void fitTheViewVFH(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fitTheViewVFH(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void vfh(::RoboCompobjectDetection::listType& guesses)
    {
        vfh(guesses, 0);
    }
    void vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context& __ctx)
    {
        vfh(guesses, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_vfh(const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_vfh(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_vfh(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_vfh(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_vfh(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_vfh(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_vfh(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_vfh(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_vfh(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::RoboCompobjectDetection::listType&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
                ::RoboCompobjectDetection::listType guesses;
                try
                {
                    __proxy->end_vfh(guesses, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(guesses);
                }
            }
        
        private:
            
            ::std::function<void (const ::RoboCompobjectDetection::listType&)> _response;
        };
        return begin_vfh(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_vfh()
    {
        return begin_vfh(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_vfh(const ::Ice::Context& __ctx)
    {
        return begin_vfh(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_vfh(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_vfh(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_vfh(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_vfh(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_vfh(const ::RoboCompobjectDetection::Callback_objectDetection_vfhPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_vfh(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_vfh(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_vfhPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_vfh(&__ctx, __del, __cookie);
    }

    void end_vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::AsyncResultPtr&);
    
private:

    void vfh(::RoboCompobjectDetection::listType&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_vfh(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void surfHomography(::RoboCompobjectDetection::listType& guesses)
    {
        surfHomography(guesses, 0);
    }
    void surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context& __ctx)
    {
        surfHomography(guesses, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_surfHomography(const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_surfHomography(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_surfHomography(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_surfHomography(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_surfHomography(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_surfHomography(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_surfHomography(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_surfHomography(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_surfHomography(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::RoboCompobjectDetection::listType&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::RoboCompobjectDetection::listType&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
                ::RoboCompobjectDetection::listType guesses;
                try
                {
                    __proxy->end_surfHomography(guesses, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(guesses);
                }
            }
        
        private:
            
            ::std::function<void (const ::RoboCompobjectDetection::listType&)> _response;
        };
        return begin_surfHomography(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_surfHomography()
    {
        return begin_surfHomography(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_surfHomography(const ::Ice::Context& __ctx)
    {
        return begin_surfHomography(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_surfHomography(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_surfHomography(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_surfHomography(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_surfHomography(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_surfHomography(const ::RoboCompobjectDetection::Callback_objectDetection_surfHomographyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_surfHomography(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_surfHomography(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_surfHomographyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_surfHomography(&__ctx, __del, __cookie);
    }

    void end_surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::AsyncResultPtr&);
    
private:

    void surfHomography(::RoboCompobjectDetection::listType&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_surfHomography(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta)
    {
        centroidBasedPose(x, y, theta, 0);
    }
    void centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::Context& __ctx)
    {
        centroidBasedPose(x, y, theta, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_centroidBasedPose(const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_centroidBasedPose(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_centroidBasedPose(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_centroidBasedPose(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_centroidBasedPose(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_centroidBasedPose(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_centroidBasedPose(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_centroidBasedPose(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_centroidBasedPose(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Float, ::Ice::Float, ::Ice::Float)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
                ::Ice::Float x;
                ::Ice::Float y;
                ::Ice::Float theta;
                try
                {
                    __proxy->end_centroidBasedPose(x, y, theta, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(x, y, theta);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Float, ::Ice::Float, ::Ice::Float)> _response;
        };
        return begin_centroidBasedPose(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_centroidBasedPose()
    {
        return begin_centroidBasedPose(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::Ice::Context& __ctx)
    {
        return begin_centroidBasedPose(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_centroidBasedPose(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_centroidBasedPose(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::RoboCompobjectDetection::Callback_objectDetection_centroidBasedPosePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_centroidBasedPose(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_centroidBasedPosePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_centroidBasedPose(&__ctx, __del, __cookie);
    }

    void end_centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::AsyncResultPtr&);
    
private:

    void centroidBasedPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_centroidBasedPose(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void segmentImage()
    {
        segmentImage(0);
    }
    void segmentImage(const ::Ice::Context& __ctx)
    {
        segmentImage(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_segmentImage(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_segmentImage(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_segmentImage(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_segmentImage(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_segmentImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_segmentImage(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_segmentImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_segmentImage(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_segmentImage()
    {
        return begin_segmentImage(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_segmentImage(const ::Ice::Context& __ctx)
    {
        return begin_segmentImage(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_segmentImage(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_segmentImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_segmentImage(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_segmentImage(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_segmentImage(const ::RoboCompobjectDetection::Callback_objectDetection_segmentImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_segmentImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_segmentImage(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_segmentImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_segmentImage(&__ctx, __del, __cookie);
    }

    void end_segmentImage(const ::Ice::AsyncResultPtr&);
    
private:

    void segmentImage(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_segmentImage(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void grabTheAR()
    {
        grabTheAR(0);
    }
    void grabTheAR(const ::Ice::Context& __ctx)
    {
        grabTheAR(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_grabTheAR(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_grabTheAR(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_grabTheAR(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_grabTheAR(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_grabTheAR(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_grabTheAR(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_grabTheAR(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_grabTheAR(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_grabTheAR()
    {
        return begin_grabTheAR(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_grabTheAR(const ::Ice::Context& __ctx)
    {
        return begin_grabTheAR(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_grabTheAR(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabTheAR(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabTheAR(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabTheAR(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabTheAR(const ::RoboCompobjectDetection::Callback_objectDetection_grabTheARPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabTheAR(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_grabTheAR(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_grabTheARPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_grabTheAR(&__ctx, __del, __cookie);
    }

    void end_grabTheAR(const ::Ice::AsyncResultPtr&);
    
private:

    void grabTheAR(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_grabTheAR(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz)
    {
        getPose(x, y, z, rx, ry, rz, 0);
    }
    void getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::Context& __ctx)
    {
        getPose(x, y, z, rx, ry, rz, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPose(const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPose(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPose(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPose(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPose(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPose(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPose(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPose(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPose(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
                ::Ice::Float x;
                ::Ice::Float y;
                ::Ice::Float z;
                ::Ice::Float rx;
                ::Ice::Float ry;
                ::Ice::Float rz;
                try
                {
                    __proxy->end_getPose(x, y, z, rx, ry, rz, __result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(x, y, z, rx, ry, rz);
                }
            }
        
        private:
            
            ::std::function<void (::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float)> _response;
        };
        return begin_getPose(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPose()
    {
        return begin_getPose(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& __ctx)
    {
        return begin_getPose(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPose(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPose(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::RoboCompobjectDetection::Callback_objectDetection_getPosePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPose(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& __ctx, const ::RoboCompobjectDetection::Callback_objectDetection_getPosePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPose(&__ctx, __del, __cookie);
    }

    void end_getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::AsyncResultPtr&);
    
private:

    void getPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<objectDetection> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_secure(bool __secure) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_twoway() const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_oneway() const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_batchOneway() const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_datagram() const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_batchDatagram() const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_compress(bool __compress) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_timeout(int __timeout) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<objectDetection> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<objectDetection*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace RoboCompobjectDetection
{

class objectDetection : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void statisticalOutliersRemoval(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void passThrough(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void aprilFitModel(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void fitModel(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void getInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void projectInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void convexHull(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void extractPolygon(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void ransac(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void normalSegmentation(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void euclideanClustering(::Ice::Int&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void showObject(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void reset(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void mirrorPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void mindTheGapPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void reloadVFH(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void loadTrainedVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void fitTheViewVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void vfh(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void surfHomography(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void centroidBasedPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void segmentImage(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void grabTheAR(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void getPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace RoboCompobjectDetection
{

class objectDetection : virtual public ::IceDelegate::RoboCompobjectDetection::objectDetection,
                        virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void statisticalOutliersRemoval(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void passThrough(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void aprilFitModel(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void fitModel(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void getInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void projectInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void convexHull(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void extractPolygon(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void ransac(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void normalSegmentation(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void euclideanClustering(::Ice::Int&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void showObject(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void reset(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void mirrorPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void mindTheGapPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void reloadVFH(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void loadTrainedVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void fitTheViewVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void vfh(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void surfHomography(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void centroidBasedPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void segmentImage(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void grabTheAR(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void getPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace RoboCompobjectDetection
{

class objectDetection : virtual public ::IceDelegate::RoboCompobjectDetection::objectDetection,
                        virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void statisticalOutliersRemoval(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void passThrough(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void aprilFitModel(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void fitModel(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void getInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void projectInliers(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void convexHull(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void extractPolygon(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void ransac(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void normalSegmentation(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void euclideanClustering(::Ice::Int&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void showObject(::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void reset(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void mirrorPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void mindTheGapPC(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void reloadVFH(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void loadTrainedVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void fitTheViewVFH(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void vfh(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void surfHomography(::RoboCompobjectDetection::listType&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void centroidBasedPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void segmentImage(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void grabTheAR(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void getPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace RoboCompobjectDetection
{

class objectDetection : virtual public ::Ice::Object
{
public:

    typedef objectDetectionPrx ProxyType;
    typedef objectDetectionPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void statisticalOutliersRemoval(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___statisticalOutliersRemoval(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void passThrough(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___passThrough(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void grabThePointCloud(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___grabThePointCloud(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void aprilFitModel(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___aprilFitModel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void fitModel(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fitModel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getInliers(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInliers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void projectInliers(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___projectInliers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void convexHull(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___convexHull(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void extractPolygon(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___extractPolygon(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void ransac(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ransac(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void normalSegmentation(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___normalSegmentation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void euclideanClustering(::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___euclideanClustering(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void showObject(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___showObject(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reset(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mirrorPC(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mirrorPC(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mindTheGapPC(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mindTheGapPC(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reloadVFH(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reloadVFH(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void loadTrainedVFH(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___loadTrainedVFH(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void fitTheViewVFH(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fitTheViewVFH(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void vfh(::RoboCompobjectDetection::listType&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___vfh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void surfHomography(::RoboCompobjectDetection::listType&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___surfHomography(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void centroidBasedPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___centroidBasedPose(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void segmentImage(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___segmentImage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void grabTheAR(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___grabTheAR(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getPose(::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, ::Ice::Float&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPose(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const objectDetection& l, const objectDetection& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const objectDetection& l, const objectDetection& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace RoboCompobjectDetection
{

template<class T>
class CallbackNC_objectDetection_statisticalOutliersRemoval : public Callback_objectDetection_statisticalOutliersRemoval_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_statisticalOutliersRemoval(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_statisticalOutliersRemoval<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_statisticalOutliersRemoval<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_statisticalOutliersRemoval<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_statisticalOutliersRemoval<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_statisticalOutliersRemoval : public Callback_objectDetection_statisticalOutliersRemoval_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_statisticalOutliersRemoval(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_statisticalOutliersRemoval<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_statisticalOutliersRemoval<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_statisticalOutliersRemoval<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_statisticalOutliersRemovalPtr
newCallback_objectDetection_statisticalOutliersRemoval(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_statisticalOutliersRemoval<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_passThrough : public Callback_objectDetection_passThrough_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_passThrough(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_passThrough<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_passThrough<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_passThrough<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_passThrough<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_passThrough : public Callback_objectDetection_passThrough_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_passThrough(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_passThrough<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_passThrough<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_passThrough<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_passThroughPtr
newCallback_objectDetection_passThrough(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_passThrough<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_grabThePointCloud : public Callback_objectDetection_grabThePointCloud_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_grabThePointCloud(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabThePointCloud<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabThePointCloud<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabThePointCloud<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabThePointCloud<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_grabThePointCloud : public Callback_objectDetection_grabThePointCloud_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_grabThePointCloud(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabThePointCloud<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabThePointCloud<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabThePointCloud<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabThePointCloudPtr
newCallback_objectDetection_grabThePointCloud(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabThePointCloud<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_aprilFitModel : public Callback_objectDetection_aprilFitModel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_aprilFitModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_aprilFitModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_aprilFitModel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_aprilFitModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_aprilFitModel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_aprilFitModel : public Callback_objectDetection_aprilFitModel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_aprilFitModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_aprilFitModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_aprilFitModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_aprilFitModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_aprilFitModelPtr
newCallback_objectDetection_aprilFitModel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_aprilFitModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_fitModel : public Callback_objectDetection_fitModel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_fitModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitModel<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitModel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitModel<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_fitModel : public Callback_objectDetection_fitModel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_fitModel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitModel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitModelPtr
newCallback_objectDetection_fitModel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitModel<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_getInliers : public Callback_objectDetection_getInliers_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_getInliers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getInliers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getInliers<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getInliers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getInliers<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_getInliers : public Callback_objectDetection_getInliers_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_getInliers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getInliers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getInliers<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getInliers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_getInliersPtr
newCallback_objectDetection_getInliers(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getInliers<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_projectInliers : public Callback_objectDetection_projectInliers_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_projectInliers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_projectInliers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_projectInliers<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_projectInliers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_projectInliers<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_projectInliers : public Callback_objectDetection_projectInliers_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_projectInliers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_projectInliers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_projectInliers<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_projectInliers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_projectInliersPtr
newCallback_objectDetection_projectInliers(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_projectInliers<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_convexHull : public Callback_objectDetection_convexHull_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_convexHull(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_convexHull<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_convexHull<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_convexHull<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_convexHull<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_convexHull : public Callback_objectDetection_convexHull_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_convexHull(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_convexHull<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_convexHull<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_convexHull<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_convexHullPtr
newCallback_objectDetection_convexHull(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_convexHull<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_extractPolygon : public Callback_objectDetection_extractPolygon_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_extractPolygon(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_extractPolygon<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_extractPolygon<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_extractPolygon<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_extractPolygon<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_extractPolygon : public Callback_objectDetection_extractPolygon_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_extractPolygon(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_extractPolygon<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_extractPolygon<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_extractPolygon<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_extractPolygonPtr
newCallback_objectDetection_extractPolygon(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_extractPolygon<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_ransac : public Callback_objectDetection_ransac_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_ransac(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_ransac<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_ransac<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_ransac<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_ransac<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_ransac : public Callback_objectDetection_ransac_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_ransac(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_ransac<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_ransac<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_ransac<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_ransacPtr
newCallback_objectDetection_ransac(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_ransac<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_normalSegmentation : public Callback_objectDetection_normalSegmentation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_normalSegmentation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_normalSegmentation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_normalSegmentation<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_normalSegmentation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_normalSegmentation<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_normalSegmentation : public Callback_objectDetection_normalSegmentation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_normalSegmentation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_normalSegmentation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_normalSegmentation<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_normalSegmentation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_normalSegmentationPtr
newCallback_objectDetection_normalSegmentation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_normalSegmentation<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_euclideanClustering : public Callback_objectDetection_euclideanClustering_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_objectDetection_euclideanClustering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int numCluseters;
        try
        {
            __proxy->end_euclideanClustering(numCluseters, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(numCluseters);
        }
    }

    Response response;
};

template<class T> Callback_objectDetection_euclideanClusteringPtr
newCallback_objectDetection_euclideanClustering(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_euclideanClustering<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_euclideanClusteringPtr
newCallback_objectDetection_euclideanClustering(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_euclideanClustering<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_euclideanClustering : public Callback_objectDetection_euclideanClustering_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_objectDetection_euclideanClustering(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int numCluseters;
        try
        {
            __proxy->end_euclideanClustering(numCluseters, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(numCluseters, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_objectDetection_euclideanClusteringPtr
newCallback_objectDetection_euclideanClustering(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_euclideanClustering<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_euclideanClusteringPtr
newCallback_objectDetection_euclideanClustering(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_euclideanClustering<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_showObject : public Callback_objectDetection_showObject_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_showObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_showObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_showObject<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_showObject<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_showObject<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_showObject : public Callback_objectDetection_showObject_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_showObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_showObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_showObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_showObject<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_showObjectPtr
newCallback_objectDetection_showObject(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_showObject<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_reset : public Callback_objectDetection_reset_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reset<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reset<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_reset : public Callback_objectDetection_reset_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reset<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_resetPtr
newCallback_objectDetection_reset(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reset<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_mirrorPC : public Callback_objectDetection_mirrorPC_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_mirrorPC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mirrorPC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mirrorPC<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mirrorPC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mirrorPC<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_mirrorPC : public Callback_objectDetection_mirrorPC_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_mirrorPC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mirrorPC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mirrorPC<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mirrorPC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mirrorPCPtr
newCallback_objectDetection_mirrorPC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mirrorPC<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_mindTheGapPC : public Callback_objectDetection_mindTheGapPC_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_mindTheGapPC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mindTheGapPC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mindTheGapPC<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mindTheGapPC<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_mindTheGapPC<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_mindTheGapPC : public Callback_objectDetection_mindTheGapPC_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_mindTheGapPC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mindTheGapPC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mindTheGapPC<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mindTheGapPC<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_mindTheGapPCPtr
newCallback_objectDetection_mindTheGapPC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_mindTheGapPC<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_reloadVFH : public Callback_objectDetection_reloadVFH_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_reloadVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reloadVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reloadVFH<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reloadVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_reloadVFH<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_reloadVFH : public Callback_objectDetection_reloadVFH_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_reloadVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reloadVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reloadVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reloadVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_reloadVFHPtr
newCallback_objectDetection_reloadVFH(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_reloadVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_loadTrainedVFH : public Callback_objectDetection_loadTrainedVFH_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_loadTrainedVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_loadTrainedVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_loadTrainedVFH<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_loadTrainedVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_loadTrainedVFH<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_loadTrainedVFH : public Callback_objectDetection_loadTrainedVFH_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_loadTrainedVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_loadTrainedVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_loadTrainedVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_loadTrainedVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_loadTrainedVFHPtr
newCallback_objectDetection_loadTrainedVFH(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_loadTrainedVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_fitTheViewVFH : public Callback_objectDetection_fitTheViewVFH_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_fitTheViewVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitTheViewVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitTheViewVFH<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitTheViewVFH<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_fitTheViewVFH<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_fitTheViewVFH : public Callback_objectDetection_fitTheViewVFH_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_fitTheViewVFH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitTheViewVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitTheViewVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitTheViewVFH<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_fitTheViewVFHPtr
newCallback_objectDetection_fitTheViewVFH(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_fitTheViewVFH<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_vfh : public Callback_objectDetection_vfh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::RoboCompobjectDetection::listType&);

    CallbackNC_objectDetection_vfh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::RoboCompobjectDetection::listType guesses;
        try
        {
            __proxy->end_vfh(guesses, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(guesses);
        }
    }

    Response response;
};

template<class T> Callback_objectDetection_vfhPtr
newCallback_objectDetection_vfh(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_vfh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_vfhPtr
newCallback_objectDetection_vfh(T* instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_vfh<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_vfh : public Callback_objectDetection_vfh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::RoboCompobjectDetection::listType&, const CT&);

    Callback_objectDetection_vfh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::RoboCompobjectDetection::listType guesses;
        try
        {
            __proxy->end_vfh(guesses, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(guesses, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_objectDetection_vfhPtr
newCallback_objectDetection_vfh(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_vfh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_vfhPtr
newCallback_objectDetection_vfh(T* instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_vfh<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_surfHomography : public Callback_objectDetection_surfHomography_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::RoboCompobjectDetection::listType&);

    CallbackNC_objectDetection_surfHomography(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::RoboCompobjectDetection::listType guesses;
        try
        {
            __proxy->end_surfHomography(guesses, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(guesses);
        }
    }

    Response response;
};

template<class T> Callback_objectDetection_surfHomographyPtr
newCallback_objectDetection_surfHomography(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_surfHomography<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_surfHomographyPtr
newCallback_objectDetection_surfHomography(T* instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_surfHomography<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_surfHomography : public Callback_objectDetection_surfHomography_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::RoboCompobjectDetection::listType&, const CT&);

    Callback_objectDetection_surfHomography(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::RoboCompobjectDetection::listType guesses;
        try
        {
            __proxy->end_surfHomography(guesses, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(guesses, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_objectDetection_surfHomographyPtr
newCallback_objectDetection_surfHomography(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_surfHomography<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_surfHomographyPtr
newCallback_objectDetection_surfHomography(T* instance, void (T::*cb)(const ::RoboCompobjectDetection::listType&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_surfHomography<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_centroidBasedPose : public Callback_objectDetection_centroidBasedPose_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float, ::Ice::Float, ::Ice::Float);

    CallbackNC_objectDetection_centroidBasedPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float x;
        ::Ice::Float y;
        ::Ice::Float theta;
        try
        {
            __proxy->end_centroidBasedPose(x, y, theta, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(x, y, theta);
        }
    }

    Response response;
};

template<class T> Callback_objectDetection_centroidBasedPosePtr
newCallback_objectDetection_centroidBasedPose(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_centroidBasedPose<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_centroidBasedPosePtr
newCallback_objectDetection_centroidBasedPose(T* instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_centroidBasedPose<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_centroidBasedPose : public Callback_objectDetection_centroidBasedPose_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&);

    Callback_objectDetection_centroidBasedPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float x;
        ::Ice::Float y;
        ::Ice::Float theta;
        try
        {
            __proxy->end_centroidBasedPose(x, y, theta, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(x, y, theta, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_objectDetection_centroidBasedPosePtr
newCallback_objectDetection_centroidBasedPose(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_centroidBasedPose<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_centroidBasedPosePtr
newCallback_objectDetection_centroidBasedPose(T* instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_centroidBasedPose<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_segmentImage : public Callback_objectDetection_segmentImage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_segmentImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_segmentImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_segmentImage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_segmentImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_segmentImage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_segmentImage : public Callback_objectDetection_segmentImage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_segmentImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_segmentImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_segmentImage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_segmentImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_segmentImagePtr
newCallback_objectDetection_segmentImage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_segmentImage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_grabTheAR : public Callback_objectDetection_grabTheAR_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_objectDetection_grabTheAR(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabTheAR<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabTheAR<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabTheAR<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_grabTheAR<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_grabTheAR : public Callback_objectDetection_grabTheAR_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_objectDetection_grabTheAR(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabTheAR<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabTheAR<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabTheAR<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_grabTheARPtr
newCallback_objectDetection_grabTheAR(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_grabTheAR<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_objectDetection_getPose : public Callback_objectDetection_getPose_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float);

    CallbackNC_objectDetection_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float x;
        ::Ice::Float y;
        ::Ice::Float z;
        ::Ice::Float rx;
        ::Ice::Float ry;
        ::Ice::Float rz;
        try
        {
            __proxy->end_getPose(x, y, z, rx, ry, rz, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(x, y, z, rx, ry, rz);
        }
    }

    Response response;
};

template<class T> Callback_objectDetection_getPosePtr
newCallback_objectDetection_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getPose<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_objectDetection_getPosePtr
newCallback_objectDetection_getPose(T* instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_objectDetection_getPose<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_objectDetection_getPose : public Callback_objectDetection_getPose_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&);

    Callback_objectDetection_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompobjectDetection::objectDetectionPrx __proxy = ::RoboCompobjectDetection::objectDetectionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float x;
        ::Ice::Float y;
        ::Ice::Float z;
        ::Ice::Float rx;
        ::Ice::Float ry;
        ::Ice::Float rz;
        try
        {
            __proxy->end_getPose(x, y, z, rx, ry, rz, __result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(x, y, z, rx, ry, rz, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_objectDetection_getPosePtr
newCallback_objectDetection_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getPose<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_objectDetection_getPosePtr
newCallback_objectDetection_getPose(T* instance, void (T::*cb)(::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, ::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_objectDetection_getPose<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
