// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `objectDetection.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <objectDetection.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name = "statisticalOutliersRemoval";

const ::std::string __RoboCompobjectDetection__objectDetection__passThrough_name = "passThrough";

const ::std::string __RoboCompobjectDetection__objectDetection__grabThePointCloud_name = "grabThePointCloud";

const ::std::string __RoboCompobjectDetection__objectDetection__aprilFitModel_name = "aprilFitModel";

const ::std::string __RoboCompobjectDetection__objectDetection__fitModel_name = "fitModel";

const ::std::string __RoboCompobjectDetection__objectDetection__getInliers_name = "getInliers";

const ::std::string __RoboCompobjectDetection__objectDetection__projectInliers_name = "projectInliers";

const ::std::string __RoboCompobjectDetection__objectDetection__convexHull_name = "convexHull";

const ::std::string __RoboCompobjectDetection__objectDetection__extractPolygon_name = "extractPolygon";

const ::std::string __RoboCompobjectDetection__objectDetection__ransac_name = "ransac";

const ::std::string __RoboCompobjectDetection__objectDetection__normalSegmentation_name = "normalSegmentation";

const ::std::string __RoboCompobjectDetection__objectDetection__euclideanClustering_name = "euclideanClustering";

const ::std::string __RoboCompobjectDetection__objectDetection__showObject_name = "showObject";

const ::std::string __RoboCompobjectDetection__objectDetection__reset_name = "reset";

const ::std::string __RoboCompobjectDetection__objectDetection__mirrorPC_name = "mirrorPC";

const ::std::string __RoboCompobjectDetection__objectDetection__mindTheGapPC_name = "mindTheGapPC";

const ::std::string __RoboCompobjectDetection__objectDetection__reloadVFH_name = "reloadVFH";

const ::std::string __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name = "loadTrainedVFH";

const ::std::string __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name = "fitTheViewVFH";

const ::std::string __RoboCompobjectDetection__objectDetection__vfh_name = "vfh";

const ::std::string __RoboCompobjectDetection__objectDetection__surfHomography_name = "surfHomography";

const ::std::string __RoboCompobjectDetection__objectDetection__centroidBasedPose_name = "centroidBasedPose";

const ::std::string __RoboCompobjectDetection__objectDetection__segmentImage_name = "segmentImage";

const ::std::string __RoboCompobjectDetection__objectDetection__grabTheAR_name = "grabTheAR";

const ::std::string __RoboCompobjectDetection__objectDetection__getPose_name = "getPose";

}
::IceProxy::Ice::Object* ::IceProxy::RoboCompobjectDetection::upCast(::IceProxy::RoboCompobjectDetection::objectDetection* p) { return p; }

void
::IceProxy::RoboCompobjectDetection::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompobjectDetection::objectDetection>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::RoboCompobjectDetection::objectDetection;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::RoboCompobjectDetection::objectDetection::statisticalOutliersRemoval(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->statisticalOutliersRemoval(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_statisticalOutliersRemoval(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_statisticalOutliersRemoval(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::passThrough(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__passThrough_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->passThrough(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_passThrough(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__passThrough_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__passThrough_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_passThrough(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__passThrough_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__grabThePointCloud_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->grabThePointCloud(image, pcd, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__grabThePointCloud_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__grabThePointCloud_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(image);
        __os->write(pcd);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_grabThePointCloud(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__grabThePointCloud_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::aprilFitModel(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__aprilFitModel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->aprilFitModel(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_aprilFitModel(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__aprilFitModel_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__aprilFitModel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_aprilFitModel(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__aprilFitModel_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__fitModel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->fitModel(model, method, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__fitModel_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__fitModel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __os->write(method);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_fitModel(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__fitModel_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::getInliers(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__getInliers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->getInliers(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_getInliers(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__getInliers_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__getInliers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_getInliers(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__getInliers_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::projectInliers(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__projectInliers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->projectInliers(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_projectInliers(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__projectInliers_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__projectInliers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_projectInliers(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__projectInliers_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::convexHull(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__convexHull_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->convexHull(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_convexHull(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__convexHull_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__convexHull_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_convexHull(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__convexHull_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::extractPolygon(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__extractPolygon_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->extractPolygon(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_extractPolygon(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__extractPolygon_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__extractPolygon_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_extractPolygon(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__extractPolygon_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::ransac(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__ransac_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->ransac(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_ransac(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__ransac_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__ransac_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_ransac(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__ransac_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::normalSegmentation(const ::std::string& model, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__normalSegmentation_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->normalSegmentation(model, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_normalSegmentation(const ::std::string& model, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__normalSegmentation_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__normalSegmentation_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_normalSegmentation(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__normalSegmentation_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::euclideanClustering(::Ice::Int& numCluseters, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__euclideanClustering_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__RoboCompobjectDetection__objectDetection__euclideanClustering_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->euclideanClustering(numCluseters, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_euclideanClustering(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RoboCompobjectDetection__objectDetection__euclideanClustering_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__euclideanClustering_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__euclideanClustering_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_euclideanClustering(::Ice::Int& numCluseters, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RoboCompobjectDetection__objectDetection__euclideanClustering_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(numCluseters);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::RoboCompobjectDetection::objectDetection::showObject(::Ice::Int numObject, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__showObject_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->showObject(numObject, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_showObject(::Ice::Int numObject, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__showObject_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__showObject_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(numObject);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_showObject(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__showObject_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::reset(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__reset_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->reset(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_reset(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__reset_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__reset_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_reset(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__reset_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::mirrorPC(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__mirrorPC_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->mirrorPC(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_mirrorPC(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__mirrorPC_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__mirrorPC_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_mirrorPC(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__mirrorPC_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::mindTheGapPC(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__mindTheGapPC_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->mindTheGapPC(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_mindTheGapPC(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__mindTheGapPC_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__mindTheGapPC_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_mindTheGapPC(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__mindTheGapPC_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::reloadVFH(const ::std::string& pathToSet, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__reloadVFH_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->reloadVFH(pathToSet, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_reloadVFH(const ::std::string& pathToSet, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__reloadVFH_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__reloadVFH_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(pathToSet);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_reloadVFH(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__reloadVFH_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::loadTrainedVFH(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->loadTrainedVFH(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_loadTrainedVFH(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__loadTrainedVFH_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_loadTrainedVFH(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::fitTheViewVFH(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->fitTheViewVFH(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_fitTheViewVFH(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__fitTheViewVFH_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_fitTheViewVFH(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__vfh_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__RoboCompobjectDetection__objectDetection__vfh_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->vfh(guesses, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_vfh(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RoboCompobjectDetection__objectDetection__vfh_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__vfh_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__vfh_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RoboCompobjectDetection__objectDetection__vfh_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(guesses);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::RoboCompobjectDetection::objectDetection::surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__surfHomography_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__RoboCompobjectDetection__objectDetection__surfHomography_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->surfHomography(guesses, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_surfHomography(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RoboCompobjectDetection__objectDetection__surfHomography_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__surfHomography_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__surfHomography_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RoboCompobjectDetection__objectDetection__surfHomography_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(guesses);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::RoboCompobjectDetection::objectDetection::centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__centroidBasedPose_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__RoboCompobjectDetection__objectDetection__centroidBasedPose_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->centroidBasedPose(x, y, theta, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_centroidBasedPose(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RoboCompobjectDetection__objectDetection__centroidBasedPose_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__centroidBasedPose_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__centroidBasedPose_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RoboCompobjectDetection__objectDetection__centroidBasedPose_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(x);
        __is->read(y);
        __is->read(theta);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::RoboCompobjectDetection::objectDetection::segmentImage(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__segmentImage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->segmentImage(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_segmentImage(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__segmentImage_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__segmentImage_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_segmentImage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__segmentImage_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::grabTheAR(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__grabTheAR_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->grabTheAR(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_grabTheAR(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__grabTheAR_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__grabTheAR_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_grabTheAR(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __RoboCompobjectDetection__objectDetection__grabTheAR_name);
}

void
IceProxy::RoboCompobjectDetection::objectDetection::getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __RoboCompobjectDetection__objectDetection__getPose_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__RoboCompobjectDetection__objectDetection__getPose_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::RoboCompobjectDetection::objectDetection* __del = dynamic_cast< ::IceDelegate::RoboCompobjectDetection::objectDetection*>(__delBase.get());
            __del->getPose(x, y, z, rx, ry, rz, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::RoboCompobjectDetection::objectDetection::begin_getPose(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__RoboCompobjectDetection__objectDetection__getPose_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __RoboCompobjectDetection__objectDetection__getPose_name, __del, __cookie);
    try
    {
        __result->__prepare(__RoboCompobjectDetection__objectDetection__getPose_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::RoboCompobjectDetection::objectDetection::end_getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __RoboCompobjectDetection__objectDetection__getPose_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(x);
        __is->read(y);
        __is->read(z);
        __is->read(rx);
        __is->read(ry);
        __is->read(rz);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::RoboCompobjectDetection::objectDetection::ice_staticId()
{
    return ::RoboCompobjectDetection::objectDetection::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::RoboCompobjectDetection::objectDetection::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::RoboCompobjectDetection::objectDetection);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::RoboCompobjectDetection::objectDetection::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::RoboCompobjectDetection::objectDetection);
}

::IceProxy::Ice::Object*
IceProxy::RoboCompobjectDetection::objectDetection::__newInstance() const
{
    return new objectDetection;
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::statisticalOutliersRemoval(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::passThrough(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__passThrough_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__grabThePointCloud_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(image);
        __os->write(pcd);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::aprilFitModel(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__aprilFitModel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__fitModel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __os->write(method);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::getInliers(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__getInliers_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::projectInliers(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__projectInliers_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::convexHull(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__convexHull_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::extractPolygon(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__extractPolygon_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::ransac(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__ransac_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::normalSegmentation(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__normalSegmentation_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(model);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::euclideanClustering(::Ice::Int& numCluseters, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__euclideanClustering_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(numCluseters);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::showObject(::Ice::Int numObject, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__showObject_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(numObject);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::reset(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__reset_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::mirrorPC(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__mirrorPC_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::mindTheGapPC(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__mindTheGapPC_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::reloadVFH(const ::std::string& pathToSet, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__reloadVFH_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(pathToSet);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::loadTrainedVFH(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::fitTheViewVFH(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__vfh_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(guesses);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__surfHomography_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(guesses);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__centroidBasedPose_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(x);
        __is->read(y);
        __is->read(theta);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::segmentImage(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__segmentImage_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::grabTheAR(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__grabTheAR_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::RoboCompobjectDetection::objectDetection::getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __RoboCompobjectDetection__objectDetection__getPose_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(x);
        __is->read(y);
        __is->read(z);
        __is->read(rx);
        __is->read(ry);
        __is->read(rz);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::statisticalOutliersRemoval(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->statisticalOutliersRemoval(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__statisticalOutliersRemoval_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::passThrough(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->passThrough(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__passThrough_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::grabThePointCloud(const ::std::string& image, const ::std::string& pcd, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_image, const ::std::string& __p_pcd, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_image(__p_image),
            _m_pcd(__p_pcd)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->grabThePointCloud(_m_image, _m_pcd, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_image;
        const ::std::string& _m_pcd;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__grabThePointCloud_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(image, pcd, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::aprilFitModel(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->aprilFitModel(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__aprilFitModel_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::fitModel(const ::std::string& model, const ::std::string& method, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::std::string& __p_method, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model),
            _m_method(__p_method)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->fitModel(_m_model, _m_method, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
        const ::std::string& _m_method;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__fitModel_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, method, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::getInliers(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->getInliers(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__getInliers_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::projectInliers(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->projectInliers(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__projectInliers_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::convexHull(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->convexHull(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__convexHull_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::extractPolygon(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->extractPolygon(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__extractPolygon_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::ransac(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->ransac(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__ransac_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::normalSegmentation(const ::std::string& model, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_model, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_model(__p_model)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->normalSegmentation(_m_model, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_model;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__normalSegmentation_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(model, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::euclideanClustering(::Ice::Int& numCluseters, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __p_numCluseters, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_numCluseters(__p_numCluseters)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->euclideanClustering(_m_numCluseters, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _m_numCluseters;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__euclideanClustering_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(numCluseters, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::showObject(::Ice::Int numObject, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_numObject, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_numObject(__p_numObject)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->showObject(_m_numObject, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_numObject;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__showObject_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(numObject, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::reset(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->reset(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__reset_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::mirrorPC(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->mirrorPC(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__mirrorPC_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::mindTheGapPC(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->mindTheGapPC(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__mindTheGapPC_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::reloadVFH(const ::std::string& pathToSet, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_pathToSet, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_pathToSet(__p_pathToSet)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->reloadVFH(_m_pathToSet, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_pathToSet;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__reloadVFH_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(pathToSet, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::loadTrainedVFH(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->loadTrainedVFH(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__loadTrainedVFH_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::fitTheViewVFH(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->fitTheViewVFH(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__fitTheViewVFH_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::vfh(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::RoboCompobjectDetection::listType& __p_guesses, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_guesses(__p_guesses)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->vfh(_m_guesses, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::RoboCompobjectDetection::listType& _m_guesses;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__vfh_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(guesses, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::surfHomography(::RoboCompobjectDetection::listType& guesses, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::RoboCompobjectDetection::listType& __p_guesses, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_guesses(__p_guesses)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->surfHomography(_m_guesses, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::RoboCompobjectDetection::listType& _m_guesses;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__surfHomography_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(guesses, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::centroidBasedPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& theta, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __p_x, ::Ice::Float& __p_y, ::Ice::Float& __p_theta, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_x(__p_x),
            _m_y(__p_y),
            _m_theta(__p_theta)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->centroidBasedPose(_m_x, _m_y, _m_theta, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _m_x;
        ::Ice::Float& _m_y;
        ::Ice::Float& _m_theta;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__centroidBasedPose_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(x, y, theta, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::segmentImage(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->segmentImage(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__segmentImage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::grabTheAR(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->grabTheAR(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__grabTheAR_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::RoboCompobjectDetection::objectDetection::getPose(::Ice::Float& x, ::Ice::Float& y, ::Ice::Float& z, ::Ice::Float& rx, ::Ice::Float& ry, ::Ice::Float& rz, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __p_x, ::Ice::Float& __p_y, ::Ice::Float& __p_z, ::Ice::Float& __p_rx, ::Ice::Float& __p_ry, ::Ice::Float& __p_rz, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_x(__p_x),
            _m_y(__p_y),
            _m_z(__p_z),
            _m_rx(__p_rx),
            _m_ry(__p_ry),
            _m_rz(__p_rz)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::RoboCompobjectDetection::objectDetection* servant = dynamic_cast< ::RoboCompobjectDetection::objectDetection*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->getPose(_m_x, _m_y, _m_z, _m_rx, _m_ry, _m_rz, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _m_x;
        ::Ice::Float& _m_y;
        ::Ice::Float& _m_z;
        ::Ice::Float& _m_rx;
        ::Ice::Float& _m_ry;
        ::Ice::Float& _m_rz;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __RoboCompobjectDetection__objectDetection__getPose_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(x, y, z, rx, ry, rz, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Object* RoboCompobjectDetection::upCast(::RoboCompobjectDetection::objectDetection* p) { return p; }

namespace
{
const ::std::string __RoboCompobjectDetection__objectDetection_ids[2] =
{
    "::Ice::Object",
    "::RoboCompobjectDetection::objectDetection"
};

}

bool
RoboCompobjectDetection::objectDetection::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__RoboCompobjectDetection__objectDetection_ids, __RoboCompobjectDetection__objectDetection_ids + 2, _s);
}

::std::vector< ::std::string>
RoboCompobjectDetection::objectDetection::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__RoboCompobjectDetection__objectDetection_ids[0], &__RoboCompobjectDetection__objectDetection_ids[2]);
}

const ::std::string&
RoboCompobjectDetection::objectDetection::ice_id(const ::Ice::Current&) const
{
    return __RoboCompobjectDetection__objectDetection_ids[1];
}

const ::std::string&
RoboCompobjectDetection::objectDetection::ice_staticId()
{
    return __RoboCompobjectDetection__objectDetection_ids[1];
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___statisticalOutliersRemoval(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    statisticalOutliersRemoval(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___passThrough(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    passThrough(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___grabThePointCloud(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string image;
    ::std::string pcd;
    __is->read(image);
    __is->read(pcd);
    __inS.endReadParams();
    grabThePointCloud(image, pcd, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___aprilFitModel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    aprilFitModel(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___fitModel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    ::std::string method;
    __is->read(model);
    __is->read(method);
    __inS.endReadParams();
    fitModel(model, method, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___getInliers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    getInliers(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___projectInliers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    projectInliers(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___convexHull(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    convexHull(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___extractPolygon(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    extractPolygon(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___ransac(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    ransac(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___normalSegmentation(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string model;
    __is->read(model);
    __inS.endReadParams();
    normalSegmentation(model, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___euclideanClustering(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int numCluseters;
    euclideanClustering(numCluseters, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(numCluseters);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___showObject(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int numObject;
    __is->read(numObject);
    __inS.endReadParams();
    showObject(numObject, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___reset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    reset(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___mirrorPC(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    mirrorPC(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___mindTheGapPC(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    mindTheGapPC(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___reloadVFH(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string pathToSet;
    __is->read(pathToSet);
    __inS.endReadParams();
    reloadVFH(pathToSet, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___loadTrainedVFH(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    loadTrainedVFH(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___fitTheViewVFH(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    fitTheViewVFH(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___vfh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::RoboCompobjectDetection::listType guesses;
    vfh(guesses, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(guesses);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___surfHomography(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::RoboCompobjectDetection::listType guesses;
    surfHomography(guesses, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(guesses);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___centroidBasedPose(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float theta;
    centroidBasedPose(x, y, theta, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(x);
    __os->write(y);
    __os->write(theta);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___segmentImage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    segmentImage(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___grabTheAR(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    grabTheAR(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::___getPose(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
    ::Ice::Float rx;
    ::Ice::Float ry;
    ::Ice::Float rz;
    getPose(x, y, z, rx, ry, rz, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(x);
    __os->write(y);
    __os->write(z);
    __os->write(rx);
    __os->write(ry);
    __os->write(rz);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __RoboCompobjectDetection__objectDetection_all[] =
{
    "aprilFitModel",
    "centroidBasedPose",
    "convexHull",
    "euclideanClustering",
    "extractPolygon",
    "fitModel",
    "fitTheViewVFH",
    "getInliers",
    "getPose",
    "grabTheAR",
    "grabThePointCloud",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "loadTrainedVFH",
    "mindTheGapPC",
    "mirrorPC",
    "normalSegmentation",
    "passThrough",
    "projectInliers",
    "ransac",
    "reloadVFH",
    "reset",
    "segmentImage",
    "showObject",
    "statisticalOutliersRemoval",
    "surfHomography",
    "vfh"
};

}

::Ice::DispatchStatus
RoboCompobjectDetection::objectDetection::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__RoboCompobjectDetection__objectDetection_all, __RoboCompobjectDetection__objectDetection_all + 29, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __RoboCompobjectDetection__objectDetection_all)
    {
        case 0:
        {
            return ___aprilFitModel(in, current);
        }
        case 1:
        {
            return ___centroidBasedPose(in, current);
        }
        case 2:
        {
            return ___convexHull(in, current);
        }
        case 3:
        {
            return ___euclideanClustering(in, current);
        }
        case 4:
        {
            return ___extractPolygon(in, current);
        }
        case 5:
        {
            return ___fitModel(in, current);
        }
        case 6:
        {
            return ___fitTheViewVFH(in, current);
        }
        case 7:
        {
            return ___getInliers(in, current);
        }
        case 8:
        {
            return ___getPose(in, current);
        }
        case 9:
        {
            return ___grabTheAR(in, current);
        }
        case 10:
        {
            return ___grabThePointCloud(in, current);
        }
        case 11:
        {
            return ___ice_id(in, current);
        }
        case 12:
        {
            return ___ice_ids(in, current);
        }
        case 13:
        {
            return ___ice_isA(in, current);
        }
        case 14:
        {
            return ___ice_ping(in, current);
        }
        case 15:
        {
            return ___loadTrainedVFH(in, current);
        }
        case 16:
        {
            return ___mindTheGapPC(in, current);
        }
        case 17:
        {
            return ___mirrorPC(in, current);
        }
        case 18:
        {
            return ___normalSegmentation(in, current);
        }
        case 19:
        {
            return ___passThrough(in, current);
        }
        case 20:
        {
            return ___projectInliers(in, current);
        }
        case 21:
        {
            return ___ransac(in, current);
        }
        case 22:
        {
            return ___reloadVFH(in, current);
        }
        case 23:
        {
            return ___reset(in, current);
        }
        case 24:
        {
            return ___segmentImage(in, current);
        }
        case 25:
        {
            return ___showObject(in, current);
        }
        case 26:
        {
            return ___statisticalOutliersRemoval(in, current);
        }
        case 27:
        {
            return ___surfHomography(in, current);
        }
        case 28:
        {
            return ___vfh(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
RoboCompobjectDetection::objectDetection::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
RoboCompobjectDetection::objectDetection::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
RoboCompobjectDetection::__patch(objectDetectionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::RoboCompobjectDetection::objectDetectionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::RoboCompobjectDetection::objectDetection::ice_staticId(), v);
    }
}
