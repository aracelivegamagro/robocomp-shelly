// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `AGMWorldModel.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __AGMWorldModel_h__
#define __AGMWorldModel_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompAGMWorldModel
{

using StringDictionary = ::std::map<::std::string, ::std::string>;

struct Node
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    int nodeIdentifier;
    ::std::string nodeType;

    std::tuple<const ::RoboCompAGMWorldModel::StringDictionary&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(attributes, nodeIdentifier, nodeType);
    }
};

using NodeSequence = ::std::vector<::RoboCompAGMWorldModel::Node>;

struct Edge
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    int a;
    int b;
    ::std::string edgeType;

    std::tuple<const ::RoboCompAGMWorldModel::StringDictionary&, const int&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(attributes, a, b, edgeType);
    }
};

using EdgeSequence = ::std::vector<::RoboCompAGMWorldModel::Edge>;

struct World
{
    ::RoboCompAGMWorldModel::NodeSequence nodes;
    ::RoboCompAGMWorldModel::EdgeSequence edges;
    int version;

    std::tuple<const ::RoboCompAGMWorldModel::NodeSequence&, const ::RoboCompAGMWorldModel::EdgeSequence&, const int&> ice_tuple() const
    {
        return std::tie(nodes, edges, version);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Ice
{

template<>
struct StreamableTraits<::RoboCompAGMWorldModel::Node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompAGMWorldModel::Node, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::Node& v)
    {
        istr->readAll(v.attributes, v.nodeIdentifier, v.nodeType);
    }
};

template<>
struct StreamableTraits<::RoboCompAGMWorldModel::Edge>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompAGMWorldModel::Edge, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::Edge& v)
    {
        istr->readAll(v.attributes, v.a, v.b, v.edgeType);
    }
};

template<>
struct StreamableTraits<::RoboCompAGMWorldModel::World>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompAGMWorldModel::World, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::World& v)
    {
        istr->readAll(v.nodes, v.edges, v.version);
    }
};

}

#else // C++98 mapping

namespace RoboCompAGMWorldModel
{

typedef ::std::map< ::std::string, ::std::string> StringDictionary;

struct Node
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    ::Ice::Int nodeIdentifier;
    ::std::string nodeType;

    bool operator==(const Node& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(attributes != rhs_.attributes)
        {
            return false;
        }
        if(nodeIdentifier != rhs_.nodeIdentifier)
        {
            return false;
        }
        if(nodeType != rhs_.nodeType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Node& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(attributes < rhs_.attributes)
        {
            return true;
        }
        else if(rhs_.attributes < attributes)
        {
            return false;
        }
        if(nodeIdentifier < rhs_.nodeIdentifier)
        {
            return true;
        }
        else if(rhs_.nodeIdentifier < nodeIdentifier)
        {
            return false;
        }
        if(nodeType < rhs_.nodeType)
        {
            return true;
        }
        else if(rhs_.nodeType < nodeType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Node& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Node& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Node& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Node& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector< ::RoboCompAGMWorldModel::Node> NodeSequence;

struct Edge
{
    ::RoboCompAGMWorldModel::StringDictionary attributes;
    ::Ice::Int a;
    ::Ice::Int b;
    ::std::string edgeType;

    bool operator==(const Edge& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(attributes != rhs_.attributes)
        {
            return false;
        }
        if(a != rhs_.a)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        if(edgeType != rhs_.edgeType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Edge& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(attributes < rhs_.attributes)
        {
            return true;
        }
        else if(rhs_.attributes < attributes)
        {
            return false;
        }
        if(a < rhs_.a)
        {
            return true;
        }
        else if(rhs_.a < a)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        if(edgeType < rhs_.edgeType)
        {
            return true;
        }
        else if(rhs_.edgeType < edgeType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Edge& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Edge& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Edge& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Edge& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector< ::RoboCompAGMWorldModel::Edge> EdgeSequence;

struct World
{
    ::RoboCompAGMWorldModel::NodeSequence nodes;
    ::RoboCompAGMWorldModel::EdgeSequence edges;
    ::Ice::Int version;

    bool operator==(const World& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(nodes != rhs_.nodes)
        {
            return false;
        }
        if(edges != rhs_.edges)
        {
            return false;
        }
        if(version != rhs_.version)
        {
            return false;
        }
        return true;
    }

    bool operator<(const World& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(nodes < rhs_.nodes)
        {
            return true;
        }
        else if(rhs_.nodes < nodes)
        {
            return false;
        }
        if(edges < rhs_.edges)
        {
            return true;
        }
        else if(rhs_.edges < edges)
        {
            return false;
        }
        if(version < rhs_.version)
        {
            return true;
        }
        else if(rhs_.version < version)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const World& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const World& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const World& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const World& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::Node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompAGMWorldModel::Node, S>
{
    static void write(S* ostr, const ::RoboCompAGMWorldModel::Node& v)
    {
        ostr->write(v.attributes);
        ostr->write(v.nodeIdentifier);
        ostr->write(v.nodeType);
    }
};

template<typename S>
struct StreamReader< ::RoboCompAGMWorldModel::Node, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::Node& v)
    {
        istr->read(v.attributes);
        istr->read(v.nodeIdentifier);
        istr->read(v.nodeType);
    }
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::Edge>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompAGMWorldModel::Edge, S>
{
    static void write(S* ostr, const ::RoboCompAGMWorldModel::Edge& v)
    {
        ostr->write(v.attributes);
        ostr->write(v.a);
        ostr->write(v.b);
        ostr->write(v.edgeType);
    }
};

template<typename S>
struct StreamReader< ::RoboCompAGMWorldModel::Edge, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::Edge& v)
    {
        istr->read(v.attributes);
        istr->read(v.a);
        istr->read(v.b);
        istr->read(v.edgeType);
    }
};

template<>
struct StreamableTraits< ::RoboCompAGMWorldModel::World>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompAGMWorldModel::World, S>
{
    static void write(S* ostr, const ::RoboCompAGMWorldModel::World& v)
    {
        ostr->write(v.nodes);
        ostr->write(v.edges);
        ostr->write(v.version);
    }
};

template<typename S>
struct StreamReader< ::RoboCompAGMWorldModel::World, S>
{
    static void read(S* istr, ::RoboCompAGMWorldModel::World& v)
    {
        istr->read(v.nodes);
        istr->read(v.edges);
        istr->read(v.version);
    }
};

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
